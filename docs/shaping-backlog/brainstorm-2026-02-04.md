# Brainstorm: 2026-02-04

Generated by team brainstorm session. All 6 team members participated.

---

## Ideas by Team Member

---

## Architect

### Reviewed
- `BRIEF.md` -- Original specification with protocol design, type engine, and API layer
- `spago.yaml` -- Build config: single package, registry 72.0.1, no workspace split
- `package.json` -- JS deps: socket.io ^4.7.0, esbuild, purs-backend-es ^1.4.0 (unused in build)
- `src/PurSocket/Protocol.purs` -- `Msg` and `Call` phantom data kinds
- `src/PurSocket/Framework.purs` -- Full RowToList-based type engine with custom errors
- `src/PurSocket/Client.purs` + `Client.js` -- Client API and ESM FFI
- `src/PurSocket/Server.purs` + `Server.js` -- Server API and ESM FFI
- `src/PurSocket/Internal.purs` -- Smart constructors for NamespaceHandle, ServerSocket
- `src/PurSocket/Example/` -- Complete Protocol/Client/Server example modules
- `test/Test/Main.purs` -- Compile-time positive tests and integration tests
- `test/Test/Integration.purs` -- End-to-end tests: emit, broadcast, call, onEvent
- `test-negative/` -- 4 negative compile tests with shell runner
- `docs/cycles/2026-02-v1-implementation/cooldown/retrospective.md` -- Retro and captured ideas

### Researched
- PureScript RowToList patterns: Stable, well-established. PurSocket uses them correctly.
- Socket.IO TypeScript typed events: v4 has built-in TS support with generic interfaces. PurSocket's approach is more powerful (unified protocol row, direction constraints, capability tokens).
- Spago workspace monorepo: Auto-detection of sub-`spago.yaml` files, `--package` flag. Active 2025 development.
- PureScript FFI best practices: Key gap -- PurSocket's FFI uses `forall a` types the compiler cannot verify. No runtime validation at boundaries.
- PureScript Registry publishing: Moving to GA. `spago publish` available. PurSocket lacks `publish` section.
- purs-backend-es: Listed but not wired into build. Could significantly reduce bundle size.
- JSON codec / runtime validation: Argonaut and codec-argonaut provide decode/validate. PurSocket has zero runtime validation.

### Ideas

#### Idea 1: Spago Workspace Split (pursocket-protocol, pursocket-client, pursocket-server)
- **Problem:** Single-package structure means browser clients pull in `socket.io` server dependency. Cannot enforce at build level that client code never imports `PurSocket.Server`.
- **Rough solution:** Three packages: `pursocket-protocol` (zero JS deps), `pursocket-client` (socket.io-client), `pursocket-server` (socket.io). Users depend on protocol + whichever side they need.
- **Why now:** Before registry publishing -- splitting after is a breaking change for dependents. Spago workspace support has matured through 2025.
- **Size:** Medium

#### Idea 2: Registry-Ready Publishing Configuration
- **Problem:** No registry presence. Missing `publish` section, `LICENSE` file, `package.json` marked private. Cannot `spago install pursocket`.
- **Rough solution:** Add publish config, LICENSE, tag release, publish via `spago publish`. Primarily configuration and process work.
- **Why now:** Registry launching GA. Early library in niche means discoverability matters. Library is functionally complete.
- **Size:** Small

---

## External User

### Reviewed
- `BRIEF.md`, pitch, bet-decision -- Full project context
- `src/PurSocket/Client.purs` -- 8 functions: connect, joinNs, emit, call, callWithTimeout, onMsg, onConnect, disconnect
- `src/PurSocket/Server.purs` -- 7 functions: createServerWithPort, onConnection, onEvent, onCallEvent, broadcast, closeServer
- `src/PurSocket/Framework.purs` -- RowToList type engine with custom `Prim.TypeError` errors
- `src/PurSocket/Example/` -- Protocol, Client, Server demo modules
- `test-negative/` -- 4 negative compile tests (wrong event, namespace, direction, payload)
- README.md -- Installation, quick start, API reference

### Researched
- PureScript real-time/WebSocket libraries: No existing Socket.io wrapper. Only raw WebSocket bindings exist. PurSocket fills a genuine gap.
- Socket.io common patterns: Built-in reconnection, authentication via handshake, per-namespace middleware -- none exposed in PurSocket v1.
- PureScript library adoption pain points: Sparse documentation, steep learning curves, confusing row type errors. PurSocket's custom errors help but no runnable quick-start exists.
- TypeScript type-safe Socket.io approaches: Socket.io v4+ TS generics, tRPC, oRPC set expectations for DX quality.

### Ideas

#### Idea 1: Copy-Paste Starter Template with Runnable Server and Client
- **Problem:** No standalone runnable project to clone, run, and see messages flowing. The `examples/hello-world/` directory from DoD item 7 does not exist. Developers must reverse-engineer integration tests to understand setup. This is the friction that causes PureScript library evaluations to fail.
- **Rough solution:** `examples/chat/` directory with: own `MyProtocol.purs`, `Server/Main.purs`, `Client/Main.purs` + `index.html`, `README.md` with exact copy-paste commands. Every step literal. Testable in CI.
- **Why now:** All pieces exist in integration tests and examples. This is packaging and documentation. Difference between "the library works" and "I can use the library."
- **Size:** Small

#### Idea 2: Connection Lifecycle and Error Handling Guide
- **Problem:** No guidance on: connection readiness race conditions, disconnections, call timeouts, reconnection (do NamespaceHandles survive?), authentication (connect takes only a URL string). These determine whether PurSocket is a demo or production library.
- **Rough solution:** (1) `ConnectOptions` record type (or `connectWithOptions`) with `auth` and `reconnection`. (2) `onDisconnect` and `onReconnect` event listeners. (3) "Connection Lifecycle" guide with code snippets.
- **Why now:** Socket.io reconnection and authentication are the two most-searched topics. "How do I pass a JWT?" and "what happens on disconnect?" are the first production questions.
- **Size:** Medium

#### Idea 3: Listener Cleanup and Resource Management API
- **Problem:** `onMsg` and `onEvent` register listeners but provide no way to remove them. In SPAs with Halogen/React, components mount/unmount causing listener leaks. After 10 route changes, 10 copies of the same handler fire. This is the most common Socket.io bug. `onMsg` returns `Effect Unit` -- no unsubscribe handle.
- **Rough solution:** Change `onMsg`/`onEvent`/`onCallEvent` to return `Effect (Effect Unit)` -- inner effect is the unsubscribe function. FFI wraps callback in named ref, returns `() => socket.off(event, ref)`. Pattern is idiomatic in PureScript (mirrors Aff cancelers, Halogen subscriptions). Backward-compatible.
- **Why now:** Easier to change return type before v1 ships to registry. Getting it right in v1 means correct pattern from day one.
- **Size:** Small

---

## Product Manager

### Reviewed
- `BRIEF.md` -- Full protocol spec
- `README.md` -- Installation, quick start, API reference, scope
- All source modules -- Client, Server, Framework, Example, Internal
- Pitch, retrospective, team retro, cleanup tasks

### Researched
- Typed real-time alternatives: tRPC dominates but limited WebSocket throughput. oRPC v1 launched Dec 2025 with native WebSocket adapters, 1.6x faster type checking. Both TypeScript-only. PurSocket's standalone protocol type is more analogous to Haskell's `servant`.
- Socket.io's own typed events: Built-in TS generics since v3. Opt-in, interface-level only. PurSocket goes further with capability tokens and direction enforcement.
- typed-emitter ecosystem: `tiny-typed-emitter` has 401K weekly npm downloads -- strong demand for typed events.
- PureScript adoption challenges: Steep learning curve, limited ecosystem, difficult errors. FP-background teams who value correctness succeed.
- Developer onboarding trends 2025-2026: Top libraries emphasize interactive playground, single "copy and it works" snippet, fastest path to a working type error.

### Ideas

#### Idea 1: Clone-and-Run Starter Kit with Guided Type Error Experience
- **Problem:** No runnable demo to experience the type safety. The most convincing onboarding moment is when the developer intentionally breaks something and sees the custom error. Today that requires 15-30 minutes of PureScript tooling setup.
- **Rough solution:** `examples/hello-world/` with self-contained spago project. Single `Makefile` or shell script for setup. `GUIDED_TOUR.md` walking through 3 deliberate type errors (wrong event, direction, payload) with expected compiler output. Doubles as error message regression test.
- **Why now:** Every competitor has clone-and-run onboarding. PureScript's steep learning curve is already the barrier. The retro identified this as highest-priority next-cycle idea.
- **Size:** Small

#### Idea 2: Protocol Visualization and Documentation Generator
- **Problem:** Nested row types are powerful but visually dense. Real protocols with 10-20 namespaces become unreadable. Non-PureScript team members cannot understand the protocol. tRPC/oRPC solve this with OpenAPI generation; PurSocket has no equivalent.
- **Rough solution:** Build `pursocket-docs` tool that reads an AppProtocol type and generates readable Markdown/HTML table (Namespace, Direction, Event, Pattern, Payload, Response). Could use RowToList class to walk the type and output data, or parse `spago docs` output.
- **Why now:** As PurSocket targets registry publishing and wider adoption, the protocol becomes the shared artifact. OpenAPI/doc generation is table-stakes for typed API libraries in 2026.
- **Size:** Medium

#### Idea 3: PureScript Registry Publishing with Spago Install Onboarding
- **Problem:** Only installable as git dependency. Invisible to developers browsing Pursuit or using `spago search`. Every week off the registry is a week potential adopters can't find PurSocket.
- **Rough solution:** Verify metadata, ensure module docs render via `spago docs`, tag release, submit to registry. Update README to lead with `spago install pursocket`. Create test consumer project.
- **Why now:** Library is feature-complete. Cleanup done. No technical blocker. Every competitor is a single package manager command away.
- **Size:** Medium

---

## PureScript Specialist

### Reviewed
- All source files, build config, CI pipeline, test suites (positive, negative, integration)
- Build verified: 22/22 tests pass, 4/4 negative tests fail correctly, browser bundle succeeds (114.8kb)
- Retrospective and cleanup tasks

### Researched
- PureScript compiler: Still 0.15.x (latest 0.15.15). Stable, no breaking changes expected.
- Spago 1.0 / Registry GA: Launching early 2026. `spago publish` authenticates via SSH keys.
- RowToList patterns: PurSocket's approach is established best practice. `purescript-heterogeneous` adds complexity without benefit here.
- Custom type errors: PurSocket correctly uses `Above`, `Beside`, `QuoteLabel`, `Text`, `Fail`. Gap: payload mismatches fall through to raw `TypesDoNotUnify` instead of custom PurSocket error.
- FFI ESM best practices: PurSocket follows conventions well. Gap: no runtime validation at boundary.
- purs-backend-es: Listed but not configured. 114.8kb bundle could shrink significantly.
- purescript-spec: Supports `parallel`, hooks, focus/itOnly. Tests run sequentially with per-test server lifecycle.

### Ideas

#### Idea 1: purs-backend-es Integration and Production Bundle Optimization
- **Problem:** `purs-backend-es` listed but not wired in. No `backend` section in spago.yaml. Default codegen produces larger, slower code. 114.8kb browser bundle could shrink.
- **Rough solution:** Add `backend` section to spago.yaml, update bundle script to read from `output-es`, add CI bundle size comparison. Measure before/after.
- **Why now:** Infrastructure already installed. Low-hanging fruit. Directly addresses "zero runtime overhead" promise. Before registry publishing = optimized from day one.
- **Size:** Small

#### Idea 2: Registry Publishing with Workspace Split
- **Problem:** Only git dependency. Browser apps pull in `socket.io` server package. Single package bundles client + server.
- **Rough solution:** Split into workspace: `pursocket-protocol`, `pursocket-client`, `pursocket-server`. Publish all three to registry via `spago publish`.
- **Why now:** Registry GA launching. Publishing before ecosystem stabilizes = discoverable from day one. Workspace split solves real user problem (browser bundles pulling server code).
- **Size:** Large

---

## QA Engineer

### Reviewed
- All source files, FFI implementations, test suites, CI pipeline, retro notes
- Key observations:
  - No FFI boundary validation tests exist (all `forall a` trusted)
  - Integration tests rely on timing delays (100-500ms), not event-driven sync
  - No tests for error paths (timeouts, disconnections, handler throws)
  - No property-based tests (no purescript-quickcheck dependency)
  - Hardcoded ports (3456-3459) -- parallel execution would fail
  - No negative compile tests for `IsValidCall` (only `IsValidMsg` tested)

### Researched
- Socket.io testing best practices: Official guide recommends `beforeAll`/`afterAll` hooks, port 0 for random allocation.
- PureScript QuickCheck: Mature, integrates with purescript-spec via spec-quickcheck. Lacks shrinking but generators work well.
- WebSocket mock libraries: `socket.io-mock-ts`, `mock-socket` enable testing without real server. May not faithfully reproduce ack semantics.
- FFI testing in typed FP: Haskell relies on QuickCheck + explicit marshalling tests. PureScript's permissive FFI means boundary must be tested with runtime assertions.
- Socket.io ack timeout edge cases: `socket.timeout()` API prevents race conditions. PurSocket's `primCallImpl` correctly uses it but error path untested.

### Ideas

#### Idea 1: Event-Driven Test Synchronization and Port Randomization
- **Problem:** Hardcoded delays (100-500ms) and ports (3456-3459) make tests fragile in CI. QA retro already documented timing failure during v1.
- **Rough solution:** (1) Replace delays with event-driven waits using `makeAff` + `socket.on("connect", ...)` for namespace connections and `AVar`/`Ref` polling for message receipt. (2) Use port 0 for random allocation. (3) Add spec-level test timeouts.
- **Why now:** Flaky tests erode confidence in type safety guarantees. Fix before test suite grows.
- **Size:** Small

#### Idea 2: Error Path and Resilience Testing
- **Problem:** No tests for: call timeout, server handler throwing, emit after disconnect, type-mismatched payload from JS, `call` on a `Msg` event (missing negative test).
- **Rough solution:** Tests for: short-timeout callWithTimeout, server handler exception, post-disconnect emit behavior, type-mismatched FFI payload documentation, negative compile tests for IsValidCall.
- **Why now:** "Eliminate runtime errors" claim requires tested error behavior. Untested error paths are undocumented failure modes.
- **Size:** Medium

---

## Web Technology Expert

### Reviewed
- All source and FFI files, integration tests, bundle script, package.json, retrospective

### Key Technical Observations
1. **No room support.** `broadcast` calls `io.of("/"+ns).emit()` -- entire namespace, not targeted rooms. No `socket.join()`, `socket.to()`, `socket.leave()` in FFI.
2. **No middleware hook.** No way to run authentication/validation middleware before `onConnection`.
3. **`primJoin` creates new `io()` connection per namespace** -- may create N WebSocket connections instead of multiplexing over 1.
4. **No disconnection/reconnection handlers.** Only `onConnect` and `disconnect`, no `onDisconnect`, `onError`, `onReconnect`.

### Researched
- Socket.io v5 roadmap: No release date. v4 remains stable.
- WebTransport: Still experimental. Mainstream adoption projected 2027-2028. No urgency.
- Socket.io Redis adapter: Sharded adapter recommended. PurSocket's namespace-level broadcasts work naturally. But no room support = can't use room-level routing.
- Socket.io authentication middleware: `io.use()` with JWT is standard. PurSocket has no FFI for this.
- socket.io-client bundle: ~20kB min+gzip. Not tree-shakable. PurSocket adds PS runtime on top.
- Socket.io rooms vs namespaces: Rooms are the more important scaling/targeting primitive. PurSocket has zero room support.
- Connection state recovery: Socket.io 4.6+ has `connectionStateRecovery`. PurSocket unaware.

### Ideas

#### Idea 1: Typed Rooms and Targeted Broadcasts
- **Problem:** Only namespace-level broadcasting. Real apps use rooms for targeted delivery (chat rooms, game lobbies, user channels). Without rooms, PurSocket can't model the most common Socket.io pattern. Redis adapter's value is room-level routing.
- **Rough solution:** `RoomHandle` type (separate from `NamespaceHandle`). Server FFI: `joinRoom`, `leaveRoom`, `broadcastToRoom` wrapping `socket.join()`, `socket.leave()`, `io.of(ns).to(room).emit()`. Room name is runtime string (rooms are dynamic). Protocol's namespace/event type safety still applies.
- **Why now:** Without rooms, PurSocket can't serve non-trivial apps. Prerequisite for standalone demo. Impacts horizontal scaling.
- **Size:** Medium

#### Idea 2: Authentication Middleware FFI
- **Problem:** No middleware interception point between `createServer` and `onConnection`. Production Socket.io always runs auth middleware (`io.use()`). Users must drop to raw JS to set up auth, breaking abstraction.
- **Rough solution:** `useMiddleware` wrapping `io.of(ns).use((socket, next) => ...)`. Callback receives typed auth record, returns `Effect (Either Error Unit)`. Optionally `SocketData` type parameter on `NamespaceHandle` for authenticated user data.
- **Why now:** Authentication is a production requirement, not optional. Socket.io docs warn about this. Forces users to work around the abstraction.
- **Size:** Medium

#### Idea 3: Connection Lifecycle and Reconnection Handlers
- **Problem:** No `onDisconnect`, `onConnectError`, `onReconnect`. `primJoin` may create N WebSocket connections instead of multiplexing. No connection state recovery awareness. Makes PurSocket unsuitable for production clients needing connection status.
- **Rough solution:** (a) Add `onDisconnect`, `onConnectError`, `onReconnect` FFI. (b) Fix `primJoin` to use Manager multiplexing. (c) Optionally expose `connectionStateRecovery` option.
- **Why now:** Multiplexing issue is arguably a bug. Lifecycle handlers are essential for production. Integration tests would benefit from proper lifecycle hooks.
- **Size:** Small to Medium

---

## Summary

| # | Idea | Proposer | Size | Problem Area | Status |
|---|------|----------|------|--------------|--------|
| 1 | Spago Workspace Split (protocol/client/server) | Architect | Medium | Packaging | open |
| 2 | Registry-Ready Publishing Configuration | Architect | Small | Distribution | open |
| 3 | Copy-Paste Starter Template with Runnable Demo | External User | Small | Onboarding | **SHIPPED** (starter-chat-app cycle) |
| 4 | Connection Lifecycle and Error Handling Guide | External User | Medium | Production Readiness | open |
| 5 | Listener Cleanup / Resource Management API | External User | Small | Correctness (leaks) | open |
| 6 | Clone-and-Run Kit with Guided Type Error Tour | Product Manager | Small | Onboarding | **SHIPPED** (starter-chat-app cycle) |
| 7 | Protocol Visualization / Documentation Generator | Product Manager | Medium | Developer Experience | open |
| 8 | Registry Publishing with Spago Install | Product Manager | Medium | Distribution | open |
| 9 | purs-backend-es Integration / Bundle Optimization | PureScript Specialist | Small | Performance | **DONE** (v1 cycle cooldown) |
| 10 | Registry Publishing with Workspace Split | PureScript Specialist | Large | Distribution + Packaging | open |
| 11 | Event-Driven Test Sync and Port Randomization | QA Engineer | Small | Test Reliability | open |
| 12 | Error Path and Resilience Testing | QA Engineer | Medium | Testing | open |
| 13 | Typed Rooms and Targeted Broadcasts | Web Tech Expert | Medium | Feature Gap | open |
| 14 | Authentication Middleware FFI | Web Tech Expert | Medium | Production Readiness | open |
| 15 | Connection Lifecycle and Reconnection Handlers | Web Tech Expert | Small-Medium | Production Readiness | partially addressed (onDisconnect/socketId added) |
| 16 | Server Emit to Single Client | API Audit | Small | **Critical Gap** | **NEW** |
| 17 | Broadcast-Except-Sender | API Audit | Small | Feature Gap | **NEW** |
| 18 | HTTP Server Attachment API | Cooldown | Small | Production Readiness | deferred from cooldown |
| 19 | Client/Server Connection Options Records | API Audit | Medium | Production Readiness | **NEW** |
| 20 | GETTING_STARTED.md Guide | Cooldown | Small | Onboarding | **DONE** (cooldown I4) |
| 21 | README "New Project Setup" Section | Cooldown | Small | Onboarding | **DONE** (cooldown I6) |
| 22 | Negative Test Config Convention | Cooldown | Small | Test Infrastructure | **DONE** (cooldown I3) |
| 23 | Pre-Build API Checklist Template | Cooldown | Small | Process | **DONE** (cooldown I1) |
| 24 | Socket.io API Surface Audit | Cooldown | Small | Architecture | **DONE** (cooldown I5) |

### Status After Starter Chat App Cycle

**Completed:** 8 ideas shipped or done (3, 6, 9, 20, 21, 22, 23, 24)
**Partially addressed:** 1 (15 — onDisconnect/socketId added, but reconnection handlers still missing)
**Deferred from cooldown:** 1 (18 — needs shaping)
**New from API audit:** 3 (16, 17, 19)
**Remaining open:** 11

### Convergence Themes (Updated)

Several ideas converge across team members, suggesting high-priority areas:

1. **Registry Publishing** (Architect #2, Product Manager #8, PureScript Specialist #10) -- All three identified the distribution gap. Question is whether to publish as-is or do workspace split first.

2. ~~**Runnable Demo / Starter Kit** (External User #3, Product Manager #6)~~ -- **SHIPPED** in starter-chat-app cycle. Chat example with guided tour delivered.

3. **Server API Completeness** (**NEW top priority**) -- The API surface audit revealed PurSocket wraps only 16 of 104 Socket.io API items (15%). The three most critical gaps:
   - **#16: Server emit to single client** -- Cannot send typed messages to a specific client. Only broadcast exists. This is the highest-priority gap.
   - **#17: Broadcast-except-sender** -- Every chat/multiplayer app needs "send to everyone else."
   - **#18: HTTP server attachment** -- Standard deployment pattern, deferred from cooldown.

4. **Connection Lifecycle** (External User #4, Web Tech Expert #15) -- Production readiness requires client disconnect/reconnect/error handlers. Partially addressed (server-side onDisconnect added) but client-side lifecycle still missing.

5. **Rooms** (Web Tech Expert #13) -- Feature gap that limits PurSocket to trivial applications. API audit confirms 9 room-related API items all marked "defer."

6. **Authentication Middleware** (Web Tech Expert #14) -- Production requirement. API audit confirms server.use() and namespace.use() both missing.

7. **Listener Cleanup** (External User #5) -- Correctness issue for SPA usage. API audit confirms socket.off() and removeAllListeners() missing on both client and server.

8. **Test Reliability** (QA #11) -- Small but high-impact fix for CI stability. Hardcoded ports and timing delays.

### Recommended Next Pitch Candidates

Based on the API audit and cooldown learnings, the highest-impact next cycle would address the core server API gaps:

1. **"Server API Completeness" pitch** — emitTo (single client), broadcastExceptSender, attachToHttpServer, connection options. Small-Medium. Addresses items #16, #17, #18, #19. Design notes in `docs/api-surface-audit.md` sections 7.1-7.4.

2. **"Registry Publishing" pitch** — Publish to PureScript registry. Decide workspace split first or publish monolith. Small-Medium. Addresses items #1, #2, #8, #10.

3. **"Rooms and Middleware" pitch** — joinRoom, leaveRoom, broadcastToRoom, server.use(). Medium. Addresses items #13, #14. Design notes in audit sections 3.1-3.2.

---

## Next Steps

Pick ideas to develop into full pitches with `/project-orchestrator:project-shape "[idea-name]"`
